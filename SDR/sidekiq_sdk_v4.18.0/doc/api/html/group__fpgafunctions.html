<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Sidekiq: FPGA Functions and Definitions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="epiq_55px.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Sidekiq
   </div>
   <div id="projectbrief">Software Defined Radio card</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FPGA Functions and Definitions</div>  </div>
</div><!--header-->
<div class="contents">

<p>These functions and definitions are related to communicating and exercising the FPGA capabilities of the Sidekiq SDR.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gab51057b242b3864dd93c2d7eb6699b31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#gab51057b242b3864dd93c2d7eb6699b31">SKIQ_START_USER_FPGA_REG_ADDR</a>&#160;&#160;&#160;0x00008700</td></tr>
<tr class="memdesc:gab51057b242b3864dd93c2d7eb6699b31"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__fpgafunctions.html#gab51057b242b3864dd93c2d7eb6699b31" title="SKIQ_START_USER_FPGA_REG_ADDR is first address available in the FPGA memory map that can be user defi...">SKIQ_START_USER_FPGA_REG_ADDR</a> is first address available in the FPGA memory map that can be user defined. These 32-bit register addresses increment by 4 bytes  <a href="#gab51057b242b3864dd93c2d7eb6699b31">More...</a><br/></td></tr>
<tr class="separator:gab51057b242b3864dd93c2d7eb6699b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f84fafe2949c956eae065b0a00a115e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga9f84fafe2949c956eae065b0a00a115e">SKIQ_END_USER_FPGA_REG_ADDR</a>&#160;&#160;&#160;0x00008FFF</td></tr>
<tr class="memdesc:ga9f84fafe2949c956eae065b0a00a115e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__fpgafunctions.html#ga9f84fafe2949c956eae065b0a00a115e" title="SKIQ_END_USER_FPGA_REG_ADDR is last address of the last FPGA register available in the FPGA memory ma...">SKIQ_END_USER_FPGA_REG_ADDR</a> is last address of the last FPGA register available in the FPGA memory map that can be user defined.  <a href="#ga9f84fafe2949c956eae065b0a00a115e">More...</a><br/></td></tr>
<tr class="separator:ga9f84fafe2949c956eae065b0a00a115e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga5234bcab18f6ea660a1f0beda3168ef0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0">skiq_fpga_tx_fifo_size_t</a> { <br/>
&#160;&#160;<a class="el" href="group__fpgafunctions.html#gga5234bcab18f6ea660a1f0beda3168ef0aad94782f6f9beba8d66c4b9271bd6df0">skiq_fpga_tx_fifo_size_unknown</a> = 0, 
<a class="el" href="group__fpgafunctions.html#gga5234bcab18f6ea660a1f0beda3168ef0ab5eb52c7c2980934b3ef01b3f9828f90">skiq_fpga_tx_fifo_size_4k</a> = 1, 
<a class="el" href="group__fpgafunctions.html#gga5234bcab18f6ea660a1f0beda3168ef0aed38bdeda98a143f76436cacf1ccbcdf">skiq_fpga_tx_fifo_size_8k</a> = 2, 
<a class="el" href="group__fpgafunctions.html#gga5234bcab18f6ea660a1f0beda3168ef0a438fc21117945b3bd1289d34b59f4059">skiq_fpga_tx_fifo_size_16k</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="group__fpgafunctions.html#gga5234bcab18f6ea660a1f0beda3168ef0adc8b9cb59d0cbe9756e92c72cdc3c8b9">skiq_fpga_tx_fifo_size_32k</a> = 4, 
<a class="el" href="group__fpgafunctions.html#gga5234bcab18f6ea660a1f0beda3168ef0a67cabc71c806684730aa105c1be59515">skiq_fpga_tx_fifo_size_64k</a> = 5
<br/>
 }</td></tr>
<tr class="memdesc:ga5234bcab18f6ea660a1f0beda3168ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">FPGA Tx FIFO Size. The FIFO size is the number of packets the FPGA can hold prior to actually transmitting the data.  <a href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0">More...</a><br/></td></tr>
<tr class="separator:ga5234bcab18f6ea660a1f0beda3168ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga18abbfa59e479c357252644da9909a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga18abbfa59e479c357252644da9909a93">skiq_write_iq_pack_mode</a> (uint8_t card, bool mode)</td></tr>
<tr class="separator:ga18abbfa59e479c357252644da9909a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b60c0210ea56165a91b1bc5adcb9e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga0b60c0210ea56165a91b1bc5adcb9e99">skiq_read_iq_pack_mode</a> (uint8_t card, bool *p_mode)</td></tr>
<tr class="separator:ga0b60c0210ea56165a91b1bc5adcb9e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1e9161349cbfe814fbf2d32859d6fd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#gac1e9161349cbfe814fbf2d32859d6fd9">skiq_write_iq_order_mode</a> (uint8_t card, <a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8">skiq_iq_order_t</a> mode)</td></tr>
<tr class="separator:gac1e9161349cbfe814fbf2d32859d6fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga320b2aad2691846eedf9db73388220f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga320b2aad2691846eedf9db73388220f4">skiq_read_iq_order_mode</a> (uint8_t card, <a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8">skiq_iq_order_t</a> *p_mode)</td></tr>
<tr class="separator:ga320b2aad2691846eedf9db73388220f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a29733b475d842557a21224777e0a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga3a29733b475d842557a21224777e0a1c">skiq_write_rx_data_src</a> (uint8_t card, <a class="el" href="group__rxfunctions.html#gaf97a6b37f357925cc8f5e6366f9ffc8a">skiq_rx_hdl_t</a> hdl, <a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72">skiq_data_src_t</a> src)</td></tr>
<tr class="separator:ga3a29733b475d842557a21224777e0a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d1af2b0f050d037b83c873dcdcc908e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga0d1af2b0f050d037b83c873dcdcc908e">skiq_read_rx_data_src</a> (uint8_t card, <a class="el" href="group__rxfunctions.html#gaf97a6b37f357925cc8f5e6366f9ffc8a">skiq_rx_hdl_t</a> hdl, <a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72">skiq_data_src_t</a> *p_src)</td></tr>
<tr class="separator:ga0d1af2b0f050d037b83c873dcdcc908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1216e0e9aca29f484821ce5fcbbe5109"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga1216e0e9aca29f484821ce5fcbbe5109">skiq_read_fpga_semantic_version</a> (uint8_t card, uint8_t *p_major, uint8_t *p_minor, uint8_t *p_patch)</td></tr>
<tr class="separator:ga1216e0e9aca29f484821ce5fcbbe5109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05fc2307f9204fb90db1facdd1ef2664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga05fc2307f9204fb90db1facdd1ef2664">skiq_read_fpga_tx_fifo_size</a> (uint8_t card, <a class="el" href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0">skiq_fpga_tx_fifo_size_t</a> *p_tx_fifo_size)</td></tr>
<tr class="separator:ga05fc2307f9204fb90db1facdd1ef2664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga691141702d38c8c04636bf49b34414ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga691141702d38c8c04636bf49b34414ac">skiq_write_user_fpga_reg</a> (uint8_t card, uint32_t addr, uint32_t data)</td></tr>
<tr class="separator:ga691141702d38c8c04636bf49b34414ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bdcf2b7e22ffee67576bcfdc8ed23fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga2bdcf2b7e22ffee67576bcfdc8ed23fd">skiq_read_user_fpga_reg</a> (uint8_t card, uint32_t addr, uint32_t *p_data)</td></tr>
<tr class="separator:ga2bdcf2b7e22ffee67576bcfdc8ed23fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac81f863d5319242c1c9221e1e99d6875"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#gac81f863d5319242c1c9221e1e99d6875">skiq_write_and_verify_user_fpga_reg</a> (uint8_t card, uint32_t addr, uint32_t data)</td></tr>
<tr class="separator:gac81f863d5319242c1c9221e1e99d6875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8be9cf487832cbd1b0ea07c6397eed6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file</a> (uint8_t card, FILE *fp)</td></tr>
<tr class="separator:ga8be9cf487832cbd1b0ea07c6397eed6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85dfeb8c923c67df7dc07776c0bcd8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash</a> (uint8_t card)</td></tr>
<tr class="separator:gad85dfeb8c923c67df7dc07776c0bcd8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420142ce276037d9057ece9b2c3960fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga420142ce276037d9057ece9b2c3960fc">skiq_save_fpga_config_to_flash</a> (uint8_t card, FILE *p_file)</td></tr>
<tr class="separator:ga420142ce276037d9057ece9b2c3960fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ea453388552645ff9b29d4fd58230e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#gae1ea453388552645ff9b29d4fd58230e">skiq_verify_fpga_config_from_flash</a> (uint8_t card, FILE *p_file)</td></tr>
<tr class="separator:gae1ea453388552645ff9b29d4fd58230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5196655207f627d2e06d6d7484e8054c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga5196655207f627d2e06d6d7484e8054c">skiq_read_golden_fpga_present_in_flash</a> (uint8_t card, uint8_t *p_present)</td></tr>
<tr class="separator:ga5196655207f627d2e06d6d7484e8054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e869828162760f60f069e52aab8bb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga6e869828162760f60f069e52aab8bb26">skiq_read_last_tx_timestamp</a> (uint8_t card, <a class="el" href="group__txfunctions.html#gaf15c2bcd0a45817774b067f57c4445d1">skiq_tx_hdl_t</a> hdl, uint64_t *p_last_timestamp)</td></tr>
<tr class="separator:ga6e869828162760f60f069e52aab8bb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23a0ca6f0615ea9a3d9ad48e9aa55b9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fpgafunctions.html#ga23a0ca6f0615ea9a3d9ad48e9aa55b9c">skiq_prog_fpga_from_flash_slot</a> (uint8_t card, uint8_t slot)</td></tr>
<tr class="memdesc:ga23a0ca6f0615ea9a3d9ad48e9aa55b9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is responsible for programming the FPGA from an image stored in flash at the specified slot.  <a href="#ga23a0ca6f0615ea9a3d9ad48e9aa55b9c">More...</a><br/></td></tr>
<tr class="separator:ga23a0ca6f0615ea9a3d9ad48e9aa55b9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>These functions and definitions are related to communicating and exercising the FPGA capabilities of the Sidekiq SDR. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gab51057b242b3864dd93c2d7eb6699b31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SKIQ_START_USER_FPGA_REG_ADDR&#160;&#160;&#160;0x00008700</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__fpgafunctions.html#gab51057b242b3864dd93c2d7eb6699b31" title="SKIQ_START_USER_FPGA_REG_ADDR is first address available in the FPGA memory map that can be user defi...">SKIQ_START_USER_FPGA_REG_ADDR</a> is first address available in the FPGA memory map that can be user defined. These 32-bit register addresses increment by 4 bytes </p>

<p>Definition at line <a class="el" href="sidekiq__api_8h_source.html#l00450">450</a> of file <a class="el" href="sidekiq__api_8h_source.html">sidekiq_api.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f84fafe2949c956eae065b0a00a115e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SKIQ_END_USER_FPGA_REG_ADDR&#160;&#160;&#160;0x00008FFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="group__fpgafunctions.html#ga9f84fafe2949c956eae065b0a00a115e" title="SKIQ_END_USER_FPGA_REG_ADDR is last address of the last FPGA register available in the FPGA memory ma...">SKIQ_END_USER_FPGA_REG_ADDR</a> is last address of the last FPGA register available in the FPGA memory map that can be user defined. </p>

<p>Definition at line <a class="el" href="sidekiq__api_8h_source.html#l00454">454</a> of file <a class="el" href="sidekiq__api_8h_source.html">sidekiq_api.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga5234bcab18f6ea660a1f0beda3168ef0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0">skiq_fpga_tx_fifo_size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FPGA Tx FIFO Size. The FIFO size is the number of packets the FPGA can hold prior to actually transmitting the data. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga05fc2307f9204fb90db1facdd1ef2664">skiq_read_fpga_tx_fifo_size</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga5234bcab18f6ea660a1f0beda3168ef0aad94782f6f9beba8d66c4b9271bd6df0"></a>skiq_fpga_tx_fifo_size_unknown</em>&#160;</td><td class="fielddoc">
<p>FPGA versions prior to 2.0 did not support reporting FIFO size </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5234bcab18f6ea660a1f0beda3168ef0ab5eb52c7c2980934b3ef01b3f9828f90"></a>skiq_fpga_tx_fifo_size_4k</em>&#160;</td><td class="fielddoc">
<p>4k 32-bit words deep </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5234bcab18f6ea660a1f0beda3168ef0aed38bdeda98a143f76436cacf1ccbcdf"></a>skiq_fpga_tx_fifo_size_8k</em>&#160;</td><td class="fielddoc">
<p>8k 32-bit words deep </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5234bcab18f6ea660a1f0beda3168ef0a438fc21117945b3bd1289d34b59f4059"></a>skiq_fpga_tx_fifo_size_16k</em>&#160;</td><td class="fielddoc">
<p>16k 32-bit words deep </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5234bcab18f6ea660a1f0beda3168ef0adc8b9cb59d0cbe9756e92c72cdc3c8b9"></a>skiq_fpga_tx_fifo_size_32k</em>&#160;</td><td class="fielddoc">
<p>32k 32-bit words deep </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga5234bcab18f6ea660a1f0beda3168ef0a67cabc71c806684730aa105c1be59515"></a>skiq_fpga_tx_fifo_size_64k</em>&#160;</td><td class="fielddoc">
<p>64k 32-bit words deep </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="sidekiq__types_8h_source.html#l00720">720</a> of file <a class="el" href="sidekiq__types_8h_source.html">sidekiq_types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga18abbfa59e479c357252644da9909a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_write_iq_pack_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga18abbfa59e479c357252644da9909a93">skiq_write_iq_pack_mode()</a> function is responsible for setting whether or not the IQ samples being received/transmitted and to/from the FPGA to/from the CPU should be packed/compressed before being sent. This allows four 12-bit complex I/Q samples to be transferred in three 32-bit words, increasing the throughput efficiency of the channel. An interface defaults to using un-packed mode if the <a class="el" href="group__fpgafunctions.html#ga18abbfa59e479c357252644da9909a93">skiq_write_iq_pack_mode()</a> is not called.</p>
<dl class="section note"><dt>Note</dt><dd>That this can be changed at any time, but updates are only honored whenever streaming is started.</dd></dl>
<p>If the pack "mode" is set to false, the behavior is to have the I/Q sent up as two's complement, sign-extended, little-endian, unpacked in the following format:</p>
<pre>
        -31-------------------------------------------------------0-
        |         12-bit I0           |       12-bit Q0            |
 word 0 | (sign extended to 16 bits   | (sign extended to 16 bits) |
        ------------------------------------------------------------
        |         12-bit I1           |       12-bit Q1            |
 word 1 | (sign extended to 16 bits   | (sign extended to 16 bits) |
        ------------------------------------------------------------
        |         12-bit I2           |       12-bit Q2            |
 word 2 |  (sign extended to 16 bits  | (sign extended to 16 bits) |
        ------------------------------------------------------------
        |           ...               |          ...               |
        ------------------------------------------------------------</pre><pre></pre><p> When the mode is set to true, then the 12-bit samples are packed in to make optimal use of the available bits, and packed as follows: </p>
<pre>
        -31-------------------------------------------------------0-
 word 0 |I0b11|...|I0b0|Q0b11|.................|Q0b0|I1b11|...|I1b4|
        ------------------------------------------------------------
 word 1 |I1b3|...|I1b0|Q1b11|...|Q1b0|I2b11|...|I2b0|Q2b11|...|Q2b8|
        -31-------------------------------------------------------0-
 word 2 |Q2b7|...|Q2b0|I3b11|.................|I3b0|Q1311|....|Q3b4|
        ------------------------------------------------------------
        |           ...               |          ...               |
        ------------------------------------------------------------
 </pre><p> (with the above sequence repeated every three words)</p>
<p>Once the packed I/Q samples are received up in the CPU there are extra cycles needed to de-compress/un-pack them. However, for cases where an application simply needs to transfer a large block of contiguous I/Q samples up to the CPU for non-real time post processing, this will increase the bandwidth without sacrificing dynamic range.</p>
<dl class="section warning"><dt>Warning</dt><dd>I/Q pack mode conflicts with <a class="el" href="group__rxfunctions.html#gga361eab77dfd53779498379ef586b6b3ba26b2b3ae6ef9698a5f58eef7db55bd52">skiq_rx_stream_mode_low_latency</a>. As such, caller may not configure a card to use both packed I/Q mode and RX low latency mode at the same time. This function will return an error (<code>-EPERM</code>) if caller sets mode to true and <a class="el" href="group__rxfunctions.html#gga361eab77dfd53779498379ef586b6b3ba26b2b3ae6ef9698a5f58eef7db55bd52">skiq_rx_stream_mode_low_latency</a> is currently selected.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga0b60c0210ea56165a91b1bc5adcb9e99">skiq_read_iq_pack_mode</a> </dd>
<dd>
<a class="el" href="group__rxfunctions.html#ga534e73b8a51e3f080b3732893d291b22">skiq_read_rx_stream_mode</a> </dd>
<dd>
<a class="el" href="group__rxfunctions.html#ga1b3aa7c142727440e8170c191c4a8a1e">skiq_write_rx_stream_mode</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>false=use normal (non-packed) I/Q mode (default) true=use packed I/Q mode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b60c0210ea56165a91b1bc5adcb9e99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_iq_pack_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>p_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga0b60c0210ea56165a91b1bc5adcb9e99">skiq_read_iq_pack_mode()</a> function is responsible for retrieving the current pack mode setting for the Sidekiq card.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga18abbfa59e479c357252644da9909a93">skiq_write_iq_pack_mode</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_mode</td><td>the currently set value of the pack mode setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="gac1e9161349cbfe814fbf2d32859d6fd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_write_iq_order_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8">skiq_iq_order_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#gac1e9161349cbfe814fbf2d32859d6fd9">skiq_write_iq_order_mode()</a> function is responsible for setting the ordering of the complex samples for the Sidekiq card. Each sample is little-endian, twos-complement, signed, and sign-extended from 12 to 16-bits. (when appropriate for the product) By default samples are received/transmitted as I/Q pairs with 'Q' sample occurring first, followed by the 'I' sample, as depicted.</p>
<pre>
            skiq_iq_order_qi: (default)                skiq_iq_order_iq:
          -15--------------------------0-       -15--------------------------0-  
          |         12-bit Q0_A1        |       |         12-bit I0_A1        |
index 0   | (sign extended to 16 bits)  |       | (sign extended to 16 bits)  |
          -------------------------------       -------------------------------
          |         12-bit I0_A1        |       |         12-bit Q0_A1        |
index 1   | (sign extended to 16 bits)  |       | (sign extended to 16 bits)  |
          -------------------------------       -------------------------------
          |         12-bit Q1_A1        |       |         12-bit I1_A1        |
index 2   | (sign extended to 16 bits)  |       | (sign extended to 16 bits)  |
          -------------------------------       -------------------------------
          |         12-bit I1_A1        |       |         12-bit Q1_A1        |
index 3   | (sign extended to 16 bits)  |       | (sign extended to 16 bits)  |
          -------------------------------       -------------------------------
          |             ...             |       |             ...             |
          -------------------------------       -------------------------------
          |             ...             |       |             ...             |
          -15--------------------------0-       -15--------------------------0-
  </pre><dl class="section attention"><dt>Attention</dt><dd>The iq order mode is only applied when tx/rx streaming is started and thus may not reflect the current iq order state.</dd>
<dd>
If the iq order mode is set to skiq_iq_order_iq and an incompatible FPGA bitstream is then loaded via <a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file()</a> or <a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash()</a>, the mode will automatically revert to skiq_iq_order_qi without warning.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Function added in <b>v4.10.0</b>, requires FPGA <b>v3.12.0</b> or later</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga320b2aad2691846eedf9db73388220f4">skiq_read_iq_order_mode</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>[<a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8" title="An interface is configured to transmit or receive complex I/Q samples. By default samples are receive...">skiq_iq_order_t</a>] skiq_iq_order_qi = use Q/I order mode (default) skiq_iq_order_iq = use swapped order, I/Q</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>Requested card index is out of range </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>Requested card index is not initialized </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>if the FPGA version does not support IQ ordering mode </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if IQ order mode is not supported for the loaded FPGA bitstream </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if an invalid IQ order is specified. See <a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8" title="An interface is configured to transmit or receive complex I/Q samples. By default samples are receive...">skiq_iq_order_t</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga320b2aad2691846eedf9db73388220f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_iq_order_mode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8">skiq_iq_order_t</a> *&#160;</td>
          <td class="paramname"><em>p_mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga320b2aad2691846eedf9db73388220f4">skiq_read_iq_order_mode()</a> function is responsible for retrieving the current I/Q order mode setting for the Sidekiq card.</p>
<dl class="section since"><dt>Since</dt><dd>Function added in <b>v4.10.0</b>, requires FPGA <b>v3.12.0</b> or later</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#gac1e9161349cbfe814fbf2d32859d6fd9">skiq_write_iq_order_mode</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_mode</td><td>[<a class="el" href="group__cardfunctions.html#gad6ec972d5edabee2ca1c1b67777bebd8" title="An interface is configured to transmit or receive complex I/Q samples. By default samples are receive...">skiq_iq_order_t</a>] the currently set value of the order mode setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>Requested card index is out of range </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>Requested card index is not initialized </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>NULL pointer detected for <code>p_mode</code> </td></tr>
    <tr><td class="paramname">-EIO</td><td>A fault occurred communicating with the FPGA </td></tr>
    <tr><td class="paramname">-ENOSYS</td><td>FPGA does not meet minimum interface version requirements </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3a29733b475d842557a21224777e0a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_write_rx_data_src </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rxfunctions.html#gaf97a6b37f357925cc8f5e6366f9ffc8a">skiq_rx_hdl_t</a>&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72">skiq_data_src_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga3a29733b475d842557a21224777e0a1c">skiq_write_rx_data_src()</a> function is responsible for setting the data source for the Rx interface. This is typically complex I/Q samples, but can also be set to use an incrementing counter for various test purposes. This must be set prior to calling <a class="el" href="group__rxfunctions.html#ga9252282d633cae1397a9bb2e4b0a7954">skiq_start_rx_streaming()</a> for the Rx interface.</p>
<dl class="section warning"><dt>Warning</dt><dd>If set after the Rx interface has been started, the setting will be stored but will not be used until streaming is stopped and re-started for the interface.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga0d1af2b0f050d037b83c873dcdcc908e">skiq_read_rx_data_src</a> </dd>
<dd>
<a class="el" href="group__rxfunctions.html#ga3aa8d6261b9c13e12f5341c4030f3da9">skiq_receive</a> </dd>
<dd>
<a class="el" href="group__rxfunctions.html#ga9252282d633cae1397a9bb2e4b0a7954">skiq_start_rx_streaming</a> </dd>
<dd>
<a class="el" href="group__rxfunctions.html#gad6ebef9c9ec35dbc09695a15f0536c21">skiq_start_rx_streaming_on_1pps</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>[<a class="el" href="group__rxfunctions.html#gaf97a6b37f357925cc8f5e6366f9ffc8a" title="Sidekiq supports several Rx interface handles. The skiq_rx_hdl_t enum is used to define the different...">skiq_rx_hdl_t</a>] the handle of the requested Rx interface </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>[<a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72" title="An Rx interface is typically configured to generate complex I/Q samples. However, there are test case...">skiq_data_src_t</a>] the source of the data (either <a class="el" href="group__rxfunctions.html#gga0005f1500140f17f8d628f9c26ad9a72af4c7f64cc567131570ee01ed36772d95">skiq_data_src_iq</a> or <a class="el" href="group__rxfunctions.html#gga0005f1500140f17f8d628f9c26ad9a72a318fe16cc69404581d5c84f5111516cc">skiq_data_src_counter</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga0d1af2b0f050d037b83c873dcdcc908e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_rx_data_src </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rxfunctions.html#gaf97a6b37f357925cc8f5e6366f9ffc8a">skiq_rx_hdl_t</a>&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72">skiq_data_src_t</a> *&#160;</td>
          <td class="paramname"><em>p_src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga0d1af2b0f050d037b83c873dcdcc908e">skiq_read_rx_data_src()</a> function is responsible for retrieving the currently set data source value (<a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72" title="An Rx interface is typically configured to generate complex I/Q samples. However, there are test case...">skiq_data_src_t</a>).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga3a29733b475d842557a21224777e0a1c">skiq_write_rx_data_src</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>[<a class="el" href="group__rxfunctions.html#gaf97a6b37f357925cc8f5e6366f9ffc8a" title="Sidekiq supports several Rx interface handles. The skiq_rx_hdl_t enum is used to define the different...">skiq_rx_hdl_t</a>] the handle of the requested Rx interface </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_src</td><td>[<a class="el" href="group__rxfunctions.html#ga0005f1500140f17f8d628f9c26ad9a72" title="An Rx interface is typically configured to generate complex I/Q samples. However, there are test case...">skiq_data_src_t</a>] the currently set value of the pack mode setting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga1216e0e9aca29f484821ce5fcbbe5109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_fpga_semantic_version </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga1216e0e9aca29f484821ce5fcbbe5109">skiq_read_fpga_semantic_version()</a> function is responsible for returning the major/minor/patch revision numbers for the currently loaded FPGA bitstream.</p>
<dl class="section since"><dt>Since</dt><dd>Function added in API <b>v4.4.0</b> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_major</td><td>a pointer to where the major rev # should be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_minor</td><td>a pointer to where the minor rev # should be returned </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_patch</td><td>a pointer to where the patch rev # should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga05fc2307f9204fb90db1facdd1ef2664"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_fpga_tx_fifo_size </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0">skiq_fpga_tx_fifo_size_t</a> *&#160;</td>
          <td class="paramname"><em>p_tx_fifo_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga05fc2307f9204fb90db1facdd1ef2664">skiq_read_fpga_tx_fifo_size()</a> function is responsible for returning the Transmit FIFO size (<a class="el" href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0" title="FPGA Tx FIFO Size. The FIFO size is the number of packets the FPGA can hold prior to actually transmi...">skiq_fpga_tx_fifo_size_t</a> representing the number of samples) for the currently loaded FPGA bitstream.</p>
<dl class="section since"><dt>Since</dt><dd>Function added in API <b>v4.4.0</b> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_tx_fifo_size</td><td>[<a class="el" href="group__fpgafunctions.html#ga5234bcab18f6ea660a1f0beda3168ef0" title="FPGA Tx FIFO Size. The FIFO size is the number of packets the FPGA can hold prior to actually transmi...">skiq_fpga_tx_fifo_size_t</a>] reference to where the TX FIFO size enum should be returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga691141702d38c8c04636bf49b34414ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_write_user_fpga_reg </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga691141702d38c8c04636bf49b34414ac">skiq_write_user_fpga_reg()</a> function is used to update the 32-bit value of the requested user-definable FPGA register. This function is useful when adding custom logic to the FPGA, which can then controlled by software through this interface.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga2bdcf2b7e22ffee67576bcfdc8ed23fd">skiq_read_user_fpga_reg</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the register address to access in the FPGA's memory map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the 32-bit value to be written to the requested FPGA reg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga2bdcf2b7e22ffee67576bcfdc8ed23fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_user_fpga_reg </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga2bdcf2b7e22ffee67576bcfdc8ed23fd">skiq_read_user_fpga_reg()</a> function is responsible for reading out the current value in a user-definable FPGA register.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga691141702d38c8c04636bf49b34414ac">skiq_write_user_fpga_reg</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the register address to access in the FPGA's memory map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_data</td><td>a pointer to a uint32_t to be updated with the current value of the requested FPGA register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="gac81f863d5319242c1c9221e1e99d6875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_write_and_verify_user_fpga_reg </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#gac81f863d5319242c1c9221e1e99d6875">skiq_write_and_verify_user_fpga_reg()</a> function is used to update the 32-bit value of the requested user-definable FPGA register. After the register has been written, this function verifies that reading the register returns the value previously written. This is useful to ensure that an FPGA register contains the expected value. This verification should be done in cases when performing a read immediately following the write since it is possible that the reads and writes could occur out-of-order, depending on the transport. Additionally, this is useful to verify in the cases where the register clock is running at a slower rate, such as the sample rate clock.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga2bdcf2b7e22ffee67576bcfdc8ed23fd">skiq_read_user_fpga_reg</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga691141702d38c8c04636bf49b34414ac">skiq_write_user_fpga_reg</a></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Function added in API <b>v4.9.0</b> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>the register address to access in the FPGA's memory map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>the 32-bit value to be written to the requested FPGA reg</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>successful write and verification of user FPGA register </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>specified card index is out of range </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>addr is outside of valid FPGA user address range </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>specified card index has not been initialized </td></tr>
    <tr><td class="paramname">-EIO</td><td>data readback does not match what was written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8be9cf487832cbd1b0ea07c6397eed6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_prog_fpga_from_file </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file()</a> function is responsible for programming the FPGA with an already opened bitstream file. This allows libsidekiq-based apps to reprogram the FPGA at run-time if needed.</p>
<dl class="section note"><dt>Note</dt><dd>After successful reprogramming is complete, all RX interfaces are reset to the idle (not streaming) state.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not all Sidekiq products support programming the FPGA from a file.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga23a0ca6f0615ea9a3d9ad48e9aa55b9c" title="This function is responsible for programming the FPGA from an image stored in flash at the specified ...">skiq_prog_fpga_from_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga420142ce276037d9057ece9b2c3960fc">skiq_save_fpga_config_to_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga3fa7b7344fa54b64c4f3bd28e851d663" title="This function stores a FPGA bitstream into flash memory at the specified slot. If the slot is 0...">skiq_save_fpga_config_to_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gae1ea453388552645ff9b29d4fd58230e">skiq_verify_fpga_config_from_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#gad12bc40ae9b77d81d54bae819d627cf8" title="This function verifies the contents of flash memory at a specified against the provided FILE referenc...">skiq_verify_fpga_config_in_flash_slot</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fp</td><td>pointer to already opened configuration file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, else a negative errno value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>The specified card index exceeds the maximum (<a class="el" href="sidekiq__api_8h.html#a480de8f4283dc89d475a101c58e22421" title="SKIQ_MAX_NUM_CARDS is the maximum number of Sidekiq cards that is supported in a system ...">SKIQ_MAX_NUM_CARDS</a>) </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>A card was not detected at the specified card index </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>Configuring the FPGA from a file is not supported for this part </td></tr>
    <tr><td class="paramname">-EBADMSG</td><td>Error occurred transacting with FPGA registers </td></tr>
    <tr><td class="paramname">-EIO</td><td>Failed to configure the FPGA from the specified file pointer </td></tr>
    <tr><td class="paramname">-ESRCH</td><td>Internal error, Sidekiq transport misidentified or invalid </td></tr>
    <tr><td class="paramname">-ERANGE</td><td>Internal error, the system timestamp frequency indicated by the FPGA is out of range </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>Internal error, Sidekiq RFIC does not support querying system timestamp frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad85dfeb8c923c67df7dc07776c0bcd8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_prog_fpga_from_flash </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash()</a> function is responsible for programming the FPGA from the image previously stored in flash. This allows libsidekiq-based apps to reprogram the FPGA at run-time if needed.</p>
<dl class="section note"><dt>Note</dt><dd>After successful reprogramming is complete, all RX interfaces are reset to the idle (not streaming) state.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga23a0ca6f0615ea9a3d9ad48e9aa55b9c" title="This function is responsible for programming the FPGA from an image stored in flash at the specified ...">skiq_prog_fpga_from_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga420142ce276037d9057ece9b2c3960fc">skiq_save_fpga_config_to_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga3fa7b7344fa54b64c4f3bd28e851d663" title="This function stores a FPGA bitstream into flash memory at the specified slot. If the slot is 0...">skiq_save_fpga_config_to_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gae1ea453388552645ff9b29d4fd58230e">skiq_verify_fpga_config_from_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#gad12bc40ae9b77d81d54bae819d627cf8" title="This function verifies the contents of flash memory at a specified against the provided FILE referenc...">skiq_verify_fpga_config_in_flash_slot</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, else a negative errno value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>if the specified card index exceeds the maximum (<a class="el" href="sidekiq__api_8h.html#a480de8f4283dc89d475a101c58e22421" title="SKIQ_MAX_NUM_CARDS is the maximum number of Sidekiq cards that is supported in a system ...">SKIQ_MAX_NUM_CARDS</a>) </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if a card was not detected at the specified card index </td></tr>
    <tr><td class="paramname">-EBADMSG</td><td>Error occurred transacting with FPGA registers </td></tr>
    <tr><td class="paramname">-EIO</td><td>Failed to configure the FPGA from the stored configuration bitstream </td></tr>
    <tr><td class="paramname">-ESRCH</td><td>Internal error, Sidekiq transport misidentified or invalid </td></tr>
    <tr><td class="paramname">-ERANGE</td><td>Internal error, the system timestamp frequency indicated by the FPGA is out of range </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga420142ce276037d9057ece9b2c3960fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_save_fpga_config_to_flash </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>p_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga420142ce276037d9057ece9b2c3960fc">skiq_save_fpga_config_to_flash()</a> function stores a FPGA bitstream into flash memory, allowing it to be automatically loaded on power cycle or calling <a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga23a0ca6f0615ea9a3d9ad48e9aa55b9c" title="This function is responsible for programming the FPGA from an image stored in flash at the specified ...">skiq_prog_fpga_from_flash_slot</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga3fa7b7344fa54b64c4f3bd28e851d663" title="This function stores a FPGA bitstream into flash memory at the specified slot. If the slot is 0...">skiq_save_fpga_config_to_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gae1ea453388552645ff9b29d4fd58230e">skiq_verify_fpga_config_from_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#gad12bc40ae9b77d81d54bae819d627cf8" title="This function verifies the contents of flash memory at a specified against the provided FILE referenc...">skiq_verify_fpga_config_in_flash_slot</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_file</td><td>pointer to the FILE containing the FPGA bitstream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, else a negative errno value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>if the requested card index is out of range </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if the requested card index is not initialized </td></tr>
    <tr><td class="paramname">-EBADF</td><td>if the FILE stream references a bad file descriptor </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if no entry is found in the flash configuration array </td></tr>
    <tr><td class="paramname">-EACCES</td><td>if no golden FPGA bitstream is found in flash memory </td></tr>
    <tr><td class="paramname">-EIO</td><td>if the transport failed to read from flash memory </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if <code>p_file</code> is NULL </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if Flash access isn't supported for this card </td></tr>
    <tr><td class="paramname">-EFBIG</td><td>if the write would exceed Flash address boundaries and/or the flash config slot's size </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if the file specified by <code>p_file</code> doesn't contain an FPGA sync word </td></tr>
    <tr><td class="paramname">-ENOENT</td><td>(Internal Error) if the Flash data structure hasn't been initialized for this card </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae1ea453388552645ff9b29d4fd58230e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_verify_fpga_config_from_flash </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>p_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#gae1ea453388552645ff9b29d4fd58230e">skiq_verify_fpga_config_from_flash()</a> function verifies the contents of flash memory against a given file. This can be used to validate that a given FPGA bitstream is accurately stored within flash memory.</p>
<dl class="section since"><dt>Since</dt><dd>Function added in API <b>v4.0.0</b> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga23a0ca6f0615ea9a3d9ad48e9aa55b9c" title="This function is responsible for programming the FPGA from an image stored in flash at the specified ...">skiq_prog_fpga_from_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga420142ce276037d9057ece9b2c3960fc">skiq_save_fpga_config_to_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga3fa7b7344fa54b64c4f3bd28e851d663" title="This function stores a FPGA bitstream into flash memory at the specified slot. If the slot is 0...">skiq_save_fpga_config_to_flash_slot</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#gad12bc40ae9b77d81d54bae819d627cf8" title="This function verifies the contents of flash memory at a specified against the provided FILE referenc...">skiq_verify_fpga_config_in_flash_slot</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_file</td><td>pointer to the FILE containing the FPGA bitstream to verify</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, else a negative errno value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>if the requested card index is out of range </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if the requested card index is not initialized </td></tr>
    <tr><td class="paramname">-EFAULT</td><td>if <code>p_file</code> is NULL </td></tr>
    <tr><td class="paramname">-ENOTSUP</td><td>if Flash access isn't supported for this card </td></tr>
    <tr><td class="paramname">-EFBIG</td><td>if the file exceeds the Flash address boundaries </td></tr>
    <tr><td class="paramname">-EIO</td><td>if the file could not be read from </td></tr>
    <tr><td class="paramname">-EXDEV</td><td>if the verification failed </td></tr>
    <tr><td class="paramname">-ENOENT</td><td>(Internal Error) if the Flash data structure hasn't been initialized for this card </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5196655207f627d2e06d6d7484e8054c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_golden_fpga_present_in_flash </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga5196655207f627d2e06d6d7484e8054c">skiq_read_golden_fpga_present_in_flash()</a> function is responsible for determining if there is a valid golden image stored in flash. The p_present is set based on whether a golden FPGA image is detected:</p>
<ul>
<li>1 means the golden (fallback) FPGA is present</li>
<li>0 means the golden (fallback) FPGA is <b>NOT</b> present</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_present</td><td>pointer to where to store an indication of whether the golden image is present </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga6e869828162760f60f069e52aab8bb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_read_last_tx_timestamp </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__txfunctions.html#gaf15c2bcd0a45817774b067f57c4445d1">skiq_tx_hdl_t</a>&#160;</td>
          <td class="paramname"><em>hdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>p_last_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The <a class="el" href="group__fpgafunctions.html#ga6e869828162760f60f069e52aab8bb26">skiq_read_last_tx_timestamp()</a> function queries the FPGA to determine what transmit timestamp it last encountered. The last transmit timestamp has two interpretations. Firstly, if the current RF timestamp is greater than the timestamp returned by this function, then the FPGA has already transmitted the block. Secondly, if the current RF timestamp is less than the timestamp returned by this function, then the FPGA is holding the transmit block and waiting until the RF timestamp matches the block's transmit timestamp.</p>
<dl class="section warning"><dt>Warning</dt><dd>The last transmit timestamp is only representative if the transmit flow mode is <a class="el" href="group__txfunctions.html#ggaaaa3ad37b4d0630374dc23bb5165e08dad9fdc813dbae3bd6beba4cc42146f4ec">skiq_tx_with_timestamps_data_flow_mode</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Function added in API <b>v4.0.0</b>, requires FPGA <b>v3.5</b> or later</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__txfunctions.html#ga0c711c7324511984ff2e5e5d215b0bcb">skiq_read_tx_data_flow_mode</a> </dd>
<dd>
<a class="el" href="group__txfunctions.html#ga5c29ec88c8287047d8c9740409cadc42">skiq_write_tx_data_flow_mode</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>card index of the Sidekiq of interest </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hdl</td><td>[<a class="el" href="group__txfunctions.html#gaf15c2bcd0a45817774b067f57c4445d1" title="Sidekiq supports a single Tx interface handles. The skiq_tx_hdl_t enum is used to define the Tx inter...">skiq_tx_hdl_t</a>] transmit handle of interest </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_last_timestamp</td><td>pointer to 64-bit timestamp value, will be zero if not transmitting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int32_t status where 0=success, anything else is an error </dd></dl>

</div>
</div>
<a class="anchor" id="ga23a0ca6f0615ea9a3d9ad48e9aa55b9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="sidekiq__types_8h.html#afcebbc310ee6755ec4d96ecee539f6ce">EPIQ_API</a> int32_t skiq_prog_fpga_from_flash_slot </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>card</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is responsible for programming the FPGA from an image stored in flash at the specified slot. </p>
<dl class="section note"><dt>Note</dt><dd>A Sidekiq card can have anywhere between <code>1</code> and <code>N</code> slots available for storing FPGA images (bitstreams). Use <a class="el" href="group__flashfunctions.html#ga84a0c425b26c1d9030fed1971692b257" title="This function provides the number of FPGA configuration slots available for a specified Sidekiq card...">skiq_read_fpga_config_flash_slots_avail()</a> to query the number of slots available.</dd>
<dd>
The API function <code>skiq_prog_fpga_from_flash(card)</code> is equivalent to calling <code>skiq_prog_fpga_from_flash_slot(card, 0)</code> </dd>
<dd>
After successful reprogramming is complete, all RX interfaces are reset to the idle (not streaming) state.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Function added in API <b>v4.12.0</b> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__fpgafunctions.html#ga8be9cf487832cbd1b0ea07c6397eed6e">skiq_prog_fpga_from_file</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gad85dfeb8c923c67df7dc07776c0bcd8c">skiq_prog_fpga_from_flash</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#ga420142ce276037d9057ece9b2c3960fc">skiq_save_fpga_config_to_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga3fa7b7344fa54b64c4f3bd28e851d663" title="This function stores a FPGA bitstream into flash memory at the specified slot. If the slot is 0...">skiq_save_fpga_config_to_flash_slot</a> </dd>
<dd>
<a class="el" href="group__fpgafunctions.html#gae1ea453388552645ff9b29d4fd58230e">skiq_verify_fpga_config_from_flash</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#gad12bc40ae9b77d81d54bae819d627cf8" title="This function verifies the contents of flash memory at a specified against the provided FILE referenc...">skiq_verify_fpga_config_in_flash_slot</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga564ed6d1f7cd6a933f8df9114d05c5a6" title="This function reads the stored metadata associated with the specified slot value. ...">skiq_read_fpga_config_flash_slot_metadata</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga3013ffe936104556610ef6d8b61ed96a" title="This function uses calls to skiq_read_fpga_config_flash_slots_avail() and skiq_read_fpga_config_flash...">skiq_find_fpga_config_flash_slot_metadata</a> </dd>
<dd>
<a class="el" href="group__flashfunctions.html#ga84a0c425b26c1d9030fed1971692b257" title="This function provides the number of FPGA configuration slots available for a specified Sidekiq card...">skiq_read_fpga_config_flash_slots_avail</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">card</td><td>requested Sidekiq card ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slot</td><td>requested flash configuration slot</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, else a negative errno value </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ERANGE</td><td>if the requested card index is out of range </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if the requested card index is not initialized </td></tr>
    <tr><td class="paramname">-EIO</td><td>if an error occurred during FPGA re-programming </td></tr>
    <tr><td class="paramname">-EBADMSG</td><td>if an error occurred transacting with FPGA registers </td></tr>
    <tr><td class="paramname">-ESRCH</td><td>(Internal Error) if transport cannot be resolved after programming </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<!-- <hr class="footer"/><address class="footer"><small> -->
<!-- Generated by &#160;<a href="http://www.doxygen.org/index.html"> -->
<!-- <img class="footer" src="doxygen.png" alt="doxygen"/> -->
<!-- </a> 1.8.6 -->
<!-- </small></address> -->
<div align="center"><pre>Copyright 2013-2024 Epiq Solutions, All Rights Reserved</pre></div>
</body>
</html>
