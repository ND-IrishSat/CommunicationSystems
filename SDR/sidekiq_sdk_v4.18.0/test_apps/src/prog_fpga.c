/*! \file prog_fpga.c
 * \brief This file programs the FPGA with the
 * specified bitstream.
 *
 * <pre>
 * Copyright 2013 - 2018 Epiq Solutions, All Rights Reserved
 * </pre>
 */

#include <sidekiq_api.h>
#include <arg_parser.h>
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <inttypes.h>
#include <signal.h>
#include <unistd.h>

/* https://gcc.gnu.org/onlinedocs/gcc-4.8.5/cpp/Stringification.html */
#define xstr(s)                         str(s)
#define str(s)                          #s

#ifndef DEFAULT_CARD_NUMBER
#   define DEFAULT_CARD_NUMBER  0
#endif

#ifndef DEFAULT_CONFIG_SLOT
#   define DEFAULT_CONFIG_SLOT  0
#endif

/* these are used to provide help strings for the application when running it
   with either the "-h" or "--help" flags */
static const char* p_help_short = "- program the FPGA";
static const char* p_help_long =
"\
Program the FPGA using data sourced either from a local file or from data\n\
previously stored in flash memory on the Sidekiq.\n\
\n\
Defaults:\n\
    --card=" xstr(DEFAULT_CARD_NUMBER) "\n\
    --config-slot=" xstr(DEFAULT_CONFIG_SLOT) "\n\
";

/* Command Line Argument Variables */
/* program the FPGA using bitstream stored in external flash memory */
bool b_use_flash = false;
/* file path to FPGA bitstream */
static char* p_file_path = NULL;
/* sidekiq card number */
static uint8_t card = UINT8_MAX;
/* Sidekiq serial number */
static char* p_serial = NULL;

/* flash config slot index, set to UINT8_MAX to detect conflicting command line options */
static uint8_t config_slot = UINT8_MAX;

/* the command line arguments available with this application */
static struct application_argument p_args[] =
{
    APP_ARG_OPT("card",
                'c',
                "Specify Sidekiq by card index",
                "ID",
                &card,
                UINT8_VAR_TYPE),
    APP_ARG_OPT("serial",
                'S',
                "Specify Sidekiq by serial number",
                "SERNUM",
                &p_serial,
                STRING_VAR_TYPE),
    APP_ARG_OPT("source",
                's',
                "Bitstream file to source for programming",
                "PATH",
                &p_file_path,
                STRING_VAR_TYPE),
    APP_ARG_OPT("flash",
                0,
                "Use bitstream file stored in flash memory",
                NULL,
                &b_use_flash,
                BOOL_VAR_TYPE),
    APP_ARG_OPT("config-slot",
                0,
                "Use bitstream file stored in flash memory config slot N (implies --flash)",
                "N",
                &config_slot,
                UINT8_VAR_TYPE),
    APP_ARG_TERMINATOR,
};

/* translate from enum to string */
static const char *
fifo_cstr( skiq_fpga_tx_fifo_size_t fifo )
{
    const char* p_fifo_str =
        (fifo == skiq_fpga_tx_fifo_size_4k) ? "4k samples" :
        (fifo == skiq_fpga_tx_fifo_size_8k) ? "8k samples" :
        (fifo == skiq_fpga_tx_fifo_size_16k) ? "16k samples" :
        (fifo == skiq_fpga_tx_fifo_size_32k) ? "32k samples" :
        (fifo == skiq_fpga_tx_fifo_size_64k) ? "64k samples" :
        "unknown";

    return p_fifo_str;
}


#if (defined __MINGW32__)
/* Unfortunately Mingw does not support sigset_t, so define a fake type definition and stub out the
   related functions. */
typedef int sigset_t;
static inline int mask_signals(sigset_t *old_mask) { return 0; }
static inline int unmask_signals(sigset_t *old_mask) { return 0; }
static inline bool shutdown_signal_pending(void) { return false; }
#else
/**
    @brief  Mask (block) the SIGINT and SIGTERM signals during critical
            operations

    @param[out]  old_mask   The original signal mask, needed by
                            ::unmask_signals().

    @note   Pending signals will be raised when ::unmask_signals() is called.

    @return 0 on success, else an errno.
*/
static int
mask_signals(sigset_t *old_mask)
{
    int result = 0;
    sigset_t new_mask;

    sigemptyset(&new_mask);
    sigaddset(&new_mask, SIGINT);
    sigaddset(&new_mask, SIGTERM);

    errno = 0;
    result = pthread_sigmask(SIG_BLOCK, &new_mask, old_mask);

    return (0 == result) ? result : errno;
}

/**
    @brief  Unmask (unblock) the signals blocked by ::mask_signals().

    @param[in]  old_mask    The original signal mask, as generated by
                            ::mask_signals().

    @note   Pending signals will be processed after calling this function.

    @return 0 on success, else an errno.
*/
static int
unmask_signals(sigset_t *old_mask)
{
    int result = 0;

    errno = 0;
    result = pthread_sigmask(SIG_SETMASK, old_mask, NULL);

    return (0 == result) ? result : errno;
}

/**
    @brief  Check if a shutdown signal (SIGINT or SIGTERM) is pending (while
            masked).

    @return true if a signal is pending, else false.
*/
static bool
shutdown_signal_pending(void)
{
    int result = 0;
    sigset_t pending_mask;
    bool pending = false;

    errno = 0;
    result = sigpending(&pending_mask);
    if (0 == result)
    {
        pending = ((1 == sigismember(&pending_mask, SIGINT)) ||
                   (1 == sigismember(&pending_mask, SIGTERM)));
    }
    else
    {
        printf("Debug: sigpending() failed (%d: '%s')\n",
                errno, strerror(errno));
    }

    return pending;
}
#endif	/* __MINGW32__ */


/**
    @brief  Local function to program the FPGA

    @param[in]  card_id     The libsidekiq card number to use
    @param[in]  use_flash   If true, the Sidekiq should be programmed from the
                            bitstream currently in flash memory
    @param[in]  slot_idx    The flash config slot index (when use_flash is true)
    @param[in]  p_bitfile   If use_flash is false, this is the file name of the
                            bitstream to be stored in the Sidekiq's flash
                            memory.

    @return 0 on success, else a negative errno; see error codes from
            skiq_prog_fpga_from_file() and skiq_prog_fpga_from_flash().
    @retval -EBADF  if the file specified by p_bitfile cannot be opened
*/
static int32_t
program_fpga(uint8_t card_id, bool use_flash, uint8_t slot_idx, const char *p_bitfile)
{
    int32_t status = 0;
    FILE *pFile = NULL;

    /* Choose how to reprogram the FPGA */
    if( use_flash == false )
    {
        /* Reprogram the FPGA from a file */
        printf("Info: programming FPGA from file...\n");

        /* Open the file that contains the bitstream */
        errno = 0;
        pFile = fopen(p_bitfile, "rb");
        if( pFile == NULL )
        {
            printf("Error: unable to open %s (error code %d: '%s')\n",
                    p_bitfile, errno, strerror(errno));
            status = -1;
        }

        /* Program the file to flash */
        if( 0 == status )
        {
            status = skiq_prog_fpga_from_file(card_id, pFile);
        }
    }
    else
    {
        uint8_t nr_slots;

        status = skiq_read_fpga_config_flash_slots_avail( card, &nr_slots );
        if ( status == 0 )
        {
            printf("Info: Sidekiq card %u has %u config slot(s) available\n", card, nr_slots );
        }

        /* Reprogram the FPGA from the card's on-board flash memory. */
        if ( status == 0 )
        {
            printf("Info: programming FPGA from flash (config slot %u)...\n", slot_idx);
            status = skiq_prog_fpga_from_flash_slot(card_id, slot_idx);
        }
    }

    /* Clean up the bitfile handle (if it was opened). */
    if (NULL != pFile)
    {
        fclose(pFile);
        pFile = NULL;
    }

    return status;
}


/*****************************************************************************/
/** This is the main function for programming the FPGA

    @param argc-the # of arguments from the cmd line
    @param argv-a vector of ascii string aruments from the cmd line
    @return int-indicating status
*/
int main( int argc, char *argv[] )
{
    int32_t status = 0;
    int result = 0;

    sigset_t old_mask;
    bool masked = false;

    /* Sidekiq parameters */
    skiq_param_t skiq_params;

    /* Automatically choose the transport type. */
    skiq_xport_type_t type = skiq_xport_type_auto;
    /*
        Choose the basic initialization level; that's the minimum level needed
        to program the FPGA.
    */
    skiq_xport_init_level_t level = skiq_xport_init_level_basic;

    bool skiq_initialized = false;

    pid_t owner = 0;

    status = arg_parser(argc, argv, p_help_short, p_help_long, p_args);
    if( 0 != status )
    {
        perror("Command Line");
        arg_parser_print_help(argv[0], p_help_short, p_help_long, p_args);
        status = -1;
        goto finished;
    }

    /* when --config-slot is specified, then --flash is assumed */
    if ( UINT8_MAX != config_slot )
    {
        b_use_flash = true;
    }

    if( (NULL == p_file_path) && (false == b_use_flash) )
    {
        printf("Error: no file specified\n\n");
        arg_parser_print_help(argv[0], p_help_short, p_help_long, p_args);
        status = -1;
        goto finished;
    }

    if ( ( NULL != p_file_path ) && ( UINT8_MAX != config_slot ) )
    {
        printf("Error: cannot specify --config-slot when specifying source bitstream (--source)\n");
        arg_parser_print_help(argv[0], p_help_short, p_help_long, p_args);
        status = -1;
        goto finished;
    }

    if( (NULL != p_file_path) && (b_use_flash) )
    {
        printf("Error: must specify EITHER source bitstream (--source) or"
                " flash flag (--flash), not both\n\n");
        arg_parser_print_help(argv[0], p_help_short, p_help_long, p_args);
        status = -1;
        goto finished;
    }

    if( (UINT8_MAX != card) && (NULL != p_serial) )
    {
        printf("Error: must specify EITHER card ID or serial number, not"
                " both\n\n");
        arg_parser_print_help(argv[0], p_help_short, p_help_long, p_args);
        status = -1;
        goto finished;
    }

    if (UINT8_MAX == card)
    {
        card = DEFAULT_CARD_NUMBER;
    }

    if (UINT8_MAX == config_slot)
    {
        config_slot = DEFAULT_CONFIG_SLOT;
    }

    /* If specified, attempt to find the card with a matching serial number. */
    if ( NULL != p_serial )
    {
        status = skiq_get_card_from_serial_string(p_serial, &card);
        if (0 != status)
        {
            printf("Error: cannot find card with serial number %s (result"
                    " code %" PRIi32 ")\n", p_serial, status);
            status = -1;
            goto finished;
        }

        printf("Info: found serial number %s as card ID %" PRIu8 "\n",
                p_serial, card);
    }

    if ( (SKIQ_MAX_NUM_CARDS - 1) < card )
    {
        printf("Error: card ID %" PRIu8 " exceeds the maximum card ID"
                " (%" PRIu8 ")\n", card, (SKIQ_MAX_NUM_CARDS - 1));
        status = -1;
        goto finished;
    }

    /*
        Ignore the shutdown signals SIGINT and SIGTERM while programming the
        FPGA so the FPGA can't be only partially programmed. Blocking of these
        signals must be done here as skiq_init() can spin up threads, any of
        which can receive & handle these signals; as threads inherit the signal
        mask of the parent on creation, blocking signals now prevents any
        created threads from receiving the shutdown signals.
    */
    result = mask_signals(&old_mask);
    if (0 != result)
    {
        printf("Warning: failed to block shutdown signals (return code %d);"
                " continuing but please do not press Ctrl-C during"
                " programming.\n", result);
    }
    else
    {
        masked = true;
    }

    printf("Info: initializing card %" PRIu8 "...\n", card);

    /* Initialize libsidekiq using the specified card. */
    status = skiq_init(type, level, &card, 1);
    if( status != 0 )
    {
        if ( ( EBUSY == status ) &&
             ( 0 != skiq_is_card_avail(card, &owner) ) )
        {
            printf("Error: card %" PRIu8 " is already in use (by process ID"
                    " %u); cannot initialize card.\n", card,
                    (unsigned int) owner);
        }
        else if ( -EINVAL == status )
        {
            printf("Error: unable to initialize libsidekiq; was a valid card"
                    " specified? (result code %" PRIi32 ")\n", status);
        }
        else
        {
            printf("Error: unable to initialize libsidekiq with status %" PRIi32
                    "\n", status);
        }
        status = -1;
        goto finished;
    }
    skiq_initialized = true;

    /*
        If the signals were successfully masked, check if one of them was
        received and, if so, shut down the program. This check allows the
        user to interrupt the program before doing the uninterruptable work.
    */
    if( ( masked ) && ( shutdown_signal_pending() ) )
    {
        printf("Info: got shutdown signal\n");
        goto finished;
    }

    /* Program the FPGA */
    status = program_fpga(card, b_use_flash, config_slot, p_file_path);
    if( 0 != status )
    {
        printf("Error: failed to program FPGA (return code %" PRIi32 ")\n",
                status);
        goto finished;
    }
    else
    {
        printf("Info: FPGA programmed successfully!\n");
    }

    /*
        If the signals were successfully masked, unmask them so that the
        shutdown signals operate normally. This is done here so the user can
        interrupt the rest of the program normally (as none of the rest of the
        program has any critical operations).
    */
    if( masked )
    {
        result = unmask_signals(&old_mask);
        if (0 == result)
        {
            masked = false;
        }
    }

    /* After programming, obtain the current FPGA version info */
    if( skiq_read_parameters( card, &skiq_params ) == 0 )
    {
        skiq_fpga_param_t *fpga = &(skiq_params.fpga_param);

        if ( fpga->fpga_state == FPGA_STATE_VERSION_INACCESSIBLE )
        {
            printf( "INACCESSIBLE BITSTREAM: An invalid FPGA version number of 0.0.0 has been returned. \n" );
            printf( "Current FPGA version not available (date not available/githash not available, FIFO size not available)\n");
            
        }
        else
        {
            printf("Current FPGA version v%" PRIu8 ".%" PRIu8 ".%" PRIu8
                ", (date %x/githash 0x%x, FIFO size %s)\n",
                fpga->version_major, fpga->version_minor, fpga->version_patch,
                fpga->build_date, fpga->git_hash, fifo_cstr(fpga->tx_fifo_size));
        }

        status = 0;
    }
    else
    {
        printf("Error: unable to determine FPGA version!\n");
        status = -1;
    }

finished:
    /*
        If the shutdown signals are still masked, restore them; this is done
        as clean up.
    */
    if( masked )
    {
        (void) unmask_signals(&old_mask);
        masked = false;
    }

    /* Cleanup */
    if (skiq_initialized)
    {
        skiq_exit();
        skiq_initialized = false;
    }

    return (int) status;
}

